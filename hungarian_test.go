package hungarian_test

import (
	"github.com/arthurkushman/go-hungarian"
	"testing"
)

var testsMax = []struct {
	m      [][]float64
	result map[int]map[int]float64
}{
	{[][]float64{
		{6, 2, 3, 4, 5},
		{3, 8, 2, 8, 1},
		{9, 9, 5, 4, 2},
		{6, 7, 3, 4, 3},
		{1, 2, 6, 4, 9},
	}, map[int]map[int]float64{
		0: {2: 3},
		1: {3: 8},
		2: {0: 9},
		3: {1: 7},
		4: {4: 9},
	}},
}

func TestSolveMax(t *testing.T) {
	for _, value := range testsMax {
		assignment := hungarian.SolveMax(value.m)
		for key, val := range assignment {
			for k, v := range val {
				if _, ok := value.result[key][k]; !ok {
					for wantedK := range value.result[key] {
						t.Fatalf("Want key %d, got: %d", wantedK, k)
					}
				}
				if v != value.result[key][k] {
					t.Fatalf("key 1 %d, key 2 %d: Want %f, got: %f", key, k, value.result[key][k], v)
				}
			}
		}
	}
}

func TestSolveMaxNegative(t *testing.T) {
	testMatrix := [][]float64{
		{-1000, -1000},
		{-1000, -1000},
	}
	assignment := hungarian.SolveMax(testMatrix)
	if len(assignment) != 2 {
		t.Error("expected successful assignment")
	}
}

func TestSolveMaxStability(t *testing.T) {
	passingMatrix := [][]float64{
		{-999.00, -999.00, -999.00, -999.00, +001.94, +000.88, -999.00, -999.00, -999.00, -999.00, -999.00, -999.00, -1000.00},
		{-999.00, -999.00, -999.00, -999.00, +000.89, +001.93, -999.00, -999.00, -999.00, -999.00, -999.00, -999.00, -1000.00},
		{-999.00, -999.00, -999.00, -999.00, -999.00, -999.00, -999.00, +001.91, -999.00, -999.00, -999.00, -999.00, -1000.00},
		{-999.00, -999.00, -999.00, -999.00, -999.00, -999.00, -999.00, -999.00, -999.00, -999.00, +001.39, -999.00, -1000.00},
		{-999.00, -999.00, -999.00, -999.00, -999.00, -999.00, -999.00, -999.00, -999.00, -999.00, +001.84, -999.00, -1000.00},
		{+001.92, -999.00, -999.00, -999.00, -999.00, -999.00, -999.00, -999.00, -999.00, -999.00, -999.00, -999.00, -1000.00},
		{-999.00, +001.95, -999.00, -999.00, -999.00, -999.00, -999.00, -999.00, -999.00, -999.00, -999.00, -999.00, -1000.00},
		{-999.00, -999.00, -999.00, +001.76, -999.00, -999.00, -999.00, -999.00, -999.00, -999.00, -999.00, -999.00, -1000.00},
		{-999.00, -999.00, -999.00, -999.00, -999.00, -999.00, -999.00, -999.00, -999.00, -999.00, -999.00, +001.75, -1000.00},
		{-999.00, -999.00, -999.00, -999.00, -999.00, -999.00, -999.00, -999.00, +001.82, +000.98, -999.00, -999.00, -1000.00},
		{-999.00, -999.00, -999.00, -999.00, -999.00, -999.00, +001.81, -999.00, -999.00, -999.00, -999.00, -999.00, -1000.00},
		{+000.86, -999.00, -999.00, -999.00, -999.00, -999.00, -999.00, -999.00, -999.00, -999.00, -999.00, -999.00, -1000.00},
		{-999.00, -999.00, +001.94, -999.00, -999.00, -999.00, -999.00, -999.00, -999.00, -999.00, -999.00, -999.00, -1000.00},
	}

	// TODO - see if this can be made to be numerically stable
	failingMatrix := [][]float64{
		{-999.00, -999.00, -999.00, -999.00, -999.00, -999.00, -999.00, -999.00, 1.89, -999.00, -999.00, -999.00, -999.00, -999.00, -999.00, -999.00, -1000.00},
		{-999.00, +001.75, -999.00, -999.00, -999.00, -999.00, -999.00, -999.00, -999.00, -999.00, -999.00, -999.00, -999.00, -999.00, -999.00, -999.00, -1000.00},
		{-999.00, -999.00, -999.00, -999.00, -999.00, -999.00, -999.00, -999.00, -999.00, -999.00, -999.00, -999.00, -999.00, -999.00, -999.00, 1.91, -1000.00},
		{-999.00, -999.00, -999.00, -999.00, -999.00, -999.00, -999.00, -999.00, -999.00, -999.00, -999.00, 0.96, -999.00, 1.82, -999.00, -999.00, -1000.00},
		{-999.00, -999.00, -999.00, -999.00, -999.00, -999.00, -999.00, 1.89, -999.00, -999.00, -999.00, -999.00, -999.00, -999.00, -999.00, -999.00, -1000.00},
		{-999.00, -999.00, +001.92, -999.00, -999.00, -999.00, -999.00, -999.00, -999.00, -999.00, -999.00, -999.00, -999.00, -999.00, -999.00, -999.00, -1000.00},
		{-999.00, -999.00, -999.00, +001.95, -999.00, -999.00, -999.00, -999.00, -999.00, -999.00, -999.00, -999.00, -999.00, -999.00, -999.00, -999.00, -1000.00},
		{-999.00, -999.00, -999.00, -999.00, -999.00, -999.00, -999.00, -999.00, -999.00, 1.94, -999.00, -999.00, -999.00, -999.00, -999.00, -999.00, -1000.00},
		{-999.00, -999.00, -999.00, -999.00, -999.00, -999.00, -999.00, -999.00, -999.00, 1.2, -999.00, -999.00, -999.00, -999.00, -999.00, -999.00, -1000.00},
		{-999.00, -999.00, -999.00, -999.00, -999.00, -999.00, -999.00, -999.00, -999.00, -999.00, 1.68, -999.00, -999.00, -999.00, -999.00, -999.00, -1000.00},
		{-999.00, -999.00, -999.00, -999.00, -999.00, 1.94, -999.00, -999.00, -999.00, -999.00, -999.00, -999.00, -999.00, -999.00, -999.00, -999.00, -1000.00},
		{-999.00, -999.00, -999.00, -999.00, -999.00, -999.00, 1.93, -999.00, -999.00, -999.00, -999.00, -999.00, -999.00, -999.00, -999.00, -999.00, -1000.00},
		{-1000.00, -1000.00, -1000.00, -1000.00, -1000.00, -1000.00, -1000.00, -1000.00, -1000.00, -1000.00, -1000.00, -1000.00, -1000.00, -1000.00, -1000.00, -1000.0, -1000.00},
		{-999.00, -999.00, -999.00, -999.00, -999.00, -999.00, -999.00, -999.00, -999.00, -999.00, -999.00, 1.91, -999.00, 0.95, -999.00, -999.00, -1000.00},
		{-999.00, -999.00, -999.00, -999.00, -999.00, -999.00, -999.00, -999.00, -999.00, -999.00, -999.00, -999.00, -999.00, -999.00, 1.87, -999.00, -1000.00},
		{-999.00, -999.00, -999.00, -999.00, -999.00, -999.00, -999.00, -999.00, -999.00, -999.00, -999.00, -999.00, -999.00, -999.00, -999.00, -999.00, -1000.00},
		{+001.97, -999.00, -999.00, -999.00, -999.00, -999.00, -999.00, -999.00, -999.00, -999.00, -999.00, -999.00, -999.00, -999.00, -999.00, -999.00, -1000.00},
	}

	testFunc := func(t *testing.T, testMatrix [][]float64) {
		var expectedAssignmentCost float64
		for x := 0; x < 1000; x++ {
			assignment := hungarian.SolveMax(testMatrix)
			totalCost := 0.0
			for i := 0; i < len(testMatrix); i++ {
				for j := range assignment[i] {
					totalCost += assignment[i][j]
				}
			}

			if x == 0 {
				expectedAssignmentCost = totalCost
			}
			if expectedAssignmentCost != totalCost {
				t.Errorf("Iteration %d: expected cost to be %0.2f, got %0.2f", x, expectedAssignmentCost, totalCost)
				break
			}
			expectedAssignmentCost = totalCost
		}
	}

	t.Run("passing", func(t *testing.T) {
		testFunc(t, passingMatrix)
	})

	t.Run("failing for some reason", func(t *testing.T) {
		testFunc(t, failingMatrix)
	})

}

var testsMin = []struct {
	m [][]float64
}{
	{[][]float64{
		{6, 2, 3, 4, 5, 11, 3, 8},
		{3, 8, 2, 8, 1, 12, 5, 4},
		{7, 9, 5, 10, 2, 11, 6, 8},
		{6, 7, 3, 4, 3, 5, 5, 3},
		{1, 2, 6, 13, 9, 11, 3, 6},
		{6, 2, 3, 4, 5, 11, 3, 8},
		{4, 6, 8, 9, 7, 1, 5, 3},
		{9, 1, 2, 5, 2, 7, 3, 8},
	}},
}

func TestSolveMin(t *testing.T) {
	data := make(map[int]float64)
	for _, value := range testsMin {
		for _, val := range hungarian.SolveMin(value.m) {
			for k, v := range val {
				if val, ok := data[k]; ok {
					t.Fatalf("Repeated column %d: %f", k, val)
				}
				data[k] = v
			}
		}
	}
}

func BenchmarkSolveMax8x8(b *testing.B) {
	for i := 0; i < b.N; i++ {
		hungarian.SolveMax([][]float64{
			{6, 2, 3, 4, 5, 11, 3, 8},
			{3, 8, 2, 8, 1, 12, 5, 4},
			{7, 9, 5, 10, 2, 11, 6, 8},
			{6, 7, 3, 4, 3, 5, 5, 3},
			{1, 2, 6, 13, 9, 11, 3, 6},
			{6, 2, 3, 4, 5, 11, 3, 8},
			{4, 6, 8, 9, 7, 1, 5, 3},
			{9, 1, 2, 5, 2, 7, 3, 8},
		})
	}
}

func BenchmarkSolveMax10x10(b *testing.B) {
	for i := 0; i < b.N; i++ {
		hungarian.SolveMax([][]float64{
			{6, 2, 3, 4, 5, 11, 3, 8, 15, 18},
			{3, 8, 2, 12, 33, 8, 1, 12, 5, 4},
			{7, 9, 5, 11, 10, 2, 22, 11, 6, 8},
			{6, 7, 3, 4, 32, 3, 5, 5, 23, 3},
			{1, 2, 21, 6, 13, 9, 11, 3, 18, 6},
			{6, 2, 17, 3, 4, 41, 5, 11, 3, 8},
			{4, 6, 13, 8, 9, 7, 27, 1, 5, 3},
			{9, 1, 2, 16, 5, 2, 7, 31, 3, 8},
			{7, 1, 13, 8, 9, 4, 27, 6, 5, 3},
			{9, 2, 6, 16, 5, 1, 7, 31, 3, 8},
		})
	}
}

func BenchmarkSolveMax12x12(b *testing.B) {
	for i := 0; i < b.N; i++ {
		hungarian.SolveMax([][]float64{
			{6, 2, 72, 3, 4, 5, 11, 3, 19, 8, 15, 18},
			{3, 8, 2, 18, 12, 33, 8, 1, 34, 12, 5, 4},
			{7, 9, 5, 11, 10, 51, 2, 22, 11, 6, 15, 8},
			{6, 7, 3, 4, 32, 3, 5, 9, 5, 16, 23, 3},
			{1, 12, 2, 21, 6, 13, 9, 11, 17, 3, 18, 6},
			{6, 2, 16, 37, 17, 3, 4, 41, 5, 11, 3, 8},
			{4, 15, 6, 13, 8, 9, 7, 19, 27, 1, 5, 3},
			{9, 1, 73, 39, 2, 16, 5, 2, 7, 31, 3, 8},
			{6, 2, 72, 3, 4, 5, 11, 3, 19, 8, 15, 18},
			{3, 8, 2, 18, 12, 33, 8, 1, 34, 12, 5, 4},
			{7, 9, 5, 11, 10, 51, 2, 22, 11, 6, 15, 8},
			{6, 7, 3, 4, 32, 3, 5, 9, 5, 16, 23, 3},
		})
	}
}

func BenchmarkSolveMin8x8(b *testing.B) {
	for i := 0; i < b.N; i++ {
		hungarian.SolveMin([][]float64{
			{6, 2, 3, 4, 5, 11, 3, 8},
			{3, 8, 2, 8, 1, 12, 5, 4},
			{7, 9, 5, 10, 2, 11, 6, 8},
			{6, 7, 3, 4, 3, 5, 5, 3},
			{1, 2, 6, 13, 9, 11, 3, 6},
			{6, 2, 3, 4, 5, 11, 3, 8},
			{4, 6, 8, 9, 7, 1, 5, 3},
			{9, 1, 2, 5, 2, 7, 3, 8},
		})
	}
}

func BenchmarkSolveMin10x10(b *testing.B) {
	for i := 0; i < b.N; i++ {
		hungarian.SolveMin([][]float64{
			{6, 2, 3, 4, 5, 11, 3, 8, 15, 18},
			{3, 8, 2, 12, 33, 8, 1, 12, 5, 4},
			{7, 9, 5, 11, 10, 2, 22, 11, 6, 8},
			{6, 7, 3, 4, 32, 3, 5, 5, 23, 3},
			{1, 2, 21, 6, 13, 9, 11, 3, 18, 6},
			{6, 2, 17, 3, 4, 41, 5, 11, 3, 8},
			{4, 6, 13, 8, 9, 7, 27, 1, 5, 3},
			{9, 1, 2, 16, 5, 2, 7, 31, 3, 8},
			{7, 1, 13, 8, 9, 4, 27, 6, 5, 3},
			{9, 2, 6, 16, 5, 1, 7, 31, 3, 8},
		})
	}
}

func BenchmarkSolveMin12x12(b *testing.B) {
	for i := 0; i < b.N; i++ {
		hungarian.SolveMin([][]float64{
			{6, 2, 72, 3, 4, 5, 11, 3, 19, 8, 15, 18},
			{3, 8, 2, 18, 12, 33, 8, 1, 34, 12, 5, 4},
			{7, 9, 5, 11, 10, 51, 2, 22, 11, 6, 15, 8},
			{6, 7, 3, 4, 32, 3, 5, 9, 5, 16, 23, 3},
			{1, 12, 2, 21, 6, 13, 9, 11, 17, 3, 18, 6},
			{6, 2, 16, 37, 17, 3, 4, 41, 5, 11, 3, 8},
			{4, 15, 6, 13, 8, 9, 7, 19, 27, 1, 5, 3},
			{9, 1, 73, 39, 2, 16, 5, 2, 7, 31, 3, 8},
			{6, 2, 72, 3, 4, 5, 11, 3, 19, 8, 15, 18},
			{3, 8, 2, 18, 12, 33, 8, 1, 34, 12, 5, 4},
			{7, 9, 5, 11, 10, 51, 2, 22, 11, 6, 15, 8},
			{6, 7, 3, 4, 32, 3, 5, 9, 5, 16, 23, 3},
		})
	}
}
